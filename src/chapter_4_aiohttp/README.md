# Глава 4. Резюме

- Мы научились использовать и создавать асинхронные контекстные
менеджеры. Это специальные классы, которые позволяют 
асинхронно захватывать ресурсы, а затем освобождать их даже при 
наличии исключения. Их задача – очистить захваченные ресурсы без
лишнего кода, особенно они полезны при работе с HTTP-сеансами
и подключениями к базе данных. Для использования асинхронных
контекстных менеджеров предназначена синтаксическая конструкция async with.

- Мы можем использовать библиотеку aiohttp для отправки асинхронных веб-запросов.
Эта библиотека позволяет создавать клиенты и серверы с неблокирующими сокетами. В случае веб-клиента
мы можем конкурентно выполнять несколько запросов, не блокируя цикл событий.

- Функция asyncio.gather позволяет конкурентно запустить несколько сопрограмм и ждать их завершения.
Она возвращает управление, когда завершатся все переданные ей объекты, допускающие ожидание.
Если нужно отслеживать возникающие ошибки, то можно задать параметр return_exeptions равным True.
Тогда будут возвращаться как результаты успешно завершившихся объектов, так и возникшие исключения.

- Функция as_completed позволяет обрабатывать результаты списка
допускающих ожидание объектов по мере их завершения. Она возвращает итератор по будущим объектам,
который можно обойти. Как только сопрограмма или задача завершается, итератор отдает ее результат.

- Если мы хотим выполнить несколько задач конкурентно, но при
этом понимать, какие задачи уже завершились, а какие еще работают, то можем использовать функцию wait.
Она также дает более точный контроль над моментом возврата результатов.
После возврата мы получаем множество завершившихся задач и множество
еще работающих. Затем можем отменить какие-то задачи или снова ждать их завершения.