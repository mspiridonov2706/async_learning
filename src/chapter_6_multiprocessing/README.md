# Глава 6. Резюме

- Мы узнали, как выполнять несколько функций Python параллельно с помощью пула процессов.

- Мы научились создавать исполнитель пула процессов и запускать функции Python параллельно. 
Исполнитель пула процессов позволяет использовать такие функции asyncio API, как gather, чтобы
конкурентно выполнять несколько процессов и ждать результатов

- Мы научились решать задачи с помощью модели программирования MapReduce с применением пула процессов и asyncio.
Эта техника применима не только к MapReduce, но и вообще к любой счетной задаче,
данные для которой можно разбить на меньшие порции.

- Мы узнали, как разделять между процессами информацию о состоянии. Это позволяет собирать данные о запущенных дочерних
процессах, например счетчик чего-то

- Мы научились избегать состояний гонки с помощью блокировок. Состояние гонки возникает,
когда несколько процессов пытается обратиться к данным примерно в одно и то же время,
и чревато трудно воспроизводимыми ошибками

- Мы узнали, как использовать библиотеку multiprocessing для расширения возможностей asyncio
путем создания отдельного цикла событий в каждом процессе.
Потенциально это может повысить производительность для рабочих нагрузок, сочетающих счетные задачи и ввод-вывод
